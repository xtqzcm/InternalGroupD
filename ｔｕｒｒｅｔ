/***************/
/*
 * TURRET    TURRET     TURRET    TURRET    TURRET
 *
    ChibiOS - Copyright (C) 2006..2018 Giovanni Di Sirio

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
 * @brief This file is based on the MAPLE MINI example from ChibiOS
 *
 * @file main.cpp
 * @author Alex Au    ________这版turret是TUZKI改的啦
 * @date 2018-09-11
 */


//注意啦！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
/*还有几个要调的问题：
 * 1.PID的三个参数以及can输入的ID之类的
 * 2.具体的角度数（弧度制）
 * 3.从opencv给过来的数据要及时能传到PID操控里面
 */

#include "ch.h"
#include "hal.h"

#include "dbus.h"
#include "canBusProcess.h"

#include <stdlib.h>


static Encoder_canStruct* get;

//These are the parameters of PID controller
const float turret_kp = 1.2;
const float turret_ki = 0;
const float turret_kd = 0;
static int16_t motor_output;
static float motor_angle_sp = 2;
static float turret_init_angle;

//角度1度 = 0.017453

static void turret_init(void)
{
  // 以很小的力转到头,当每2ms的角度差值小于1°的时候判定已转到头，停止转动并记下现在的值作为初始的基准角度
  Encoder_canStruct* encoder = can_getEncoder();
  float current_rad = encoder->radian_angle;
  float previous_rad = encoder->radian_angle;
  while(true)
  {
    can_motorSetCurrent(0x200,-500,-500,-500,-500);
    if(current_rad - previous_rad < 0.0174 &&
        current_rad - previous_rad > -0.0174)
    {
      can_motorSetCurrent(0x201,0,0,0,0);
      break;
    }
    previous_rad = current_rad;
  }
  turret_init_angle = encoder->radian_angle;  //以左打到头的电机角度为初始的基准角度。。。。。初始化
}

#define left  0
#define middle  1.047197
#define right   2.094395


static int16_t pid_control(const float setPoint,
                           const float current,
                           float* error_int,
                           float* error_der)
{
  int16_t output;
  int16_t error = setPoint + turret_init_angle - current;
  int16_t YOUR_MAX_ERROR_INT = 0.5;
  int16_t dt = 2;

  static int16_t previous_error = 0;
  *error_int += error;
  *error_int *= 0.985;
  *error_der = (error - previous_error)/dt;

  if(*error_int > YOUR_MAX_ERROR_INT)
    *error_int = YOUR_MAX_ERROR_INT;
  else if(*error_int < -YOUR_MAX_ERROR_INT)
    *error_int = -YOUR_MAX_ERROR_INT;

  output = turret_kp * error + turret_ki * *error_int
      + turret_kd * *error_der;

  if (output > 60)
    output = 60;
  else if (output < 60)
    output = -60;

  previous_error = error;

  return output;
}


/************************************************
 * 这里还需要操作一下，写一个函数从CV那边读取应该打击的号码（A，B，C），
 * 再换算成应该转的角度 --- 估计是A-0，B-60， C-120
 * 传给motor_angle_sp
 */


static THD_WORKING_AREA(motor_ctrl_thread_wa,512);
static THD_FUNCTION(motor_ctrl_thread, p)
{
   (void) p;
   Encoder_canStruct* encoder = can_getEncoder();
   static float motor_error_int;
   static float motor_error_der;

   while(true)
   {
     motor_output = pid_control(motor_angle_sp,
                                encoder->radian_angle,
                                &motor_error_int,
                                &motor_error_der);
   }

   can_motorSetCurrent(0x201,motor_output,motor_output,motor_output,motor_output);
   chThdSleepMilliseconds(2);
}

int main(void)
{

    /*
    * System initializations.
    * - HAL initialization, this also initializes the configured device drivers
    *   and performs the board-specific initializations.
    * - Kernel initialization, the main() function becomes a thread and the
    *   RTOS is active.
    */
    halInit();
    chSysInit();
    can_processInit();
    //turret_init();

    chThdCreateStatic(motor_ctrl_thread_wa, sizeof(motor_ctrl_thread_wa),
                     NORMALPRIO, motor_ctrl_thread, NULL);

    /*
    * Normal main() thread activity
    */

    while (true)
    {
        palTogglePad(GPIOA, GPIOA_LED);
        chThdSleepMilliseconds(500);

    }
}

